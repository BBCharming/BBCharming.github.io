// HCIA Quiz Application - Complete Fixed Version
console.log("üöÄ HCIA Quiz Application Initializing...");

const quizState = {
    currentScreen: 'mainMenu',
    questions: [],
    currentQuestions: [],
    currentQuestionIndex: 0,
    userAnswers: [],
    quizType: '',
    selectedChapter: null,
    progress: JSON.parse(localStorage.getItem('hciaQuizProgress')) || {},
    quizStartTime: null,
    weakAreas: []
};

// HCIA Datacom Chapters with proper question distribution
const chapters = [
    { id: 1, name: "Data Communication Network Basis", expectedQuestions: 4 },
    { id: 2, name: "Network Reference Model", expectedQuestions: 4 },
    { id: 3, name: "Huawei VRP", expectedQuestions: 12 },
    { id: 4, name: "Network Layer Protocols and IP Addressing", expectedQuestions: 16 },
    { id: 5, name: "IP Routing Basics", expectedQuestions: 6 },
    { id: 6, name: "OSPF Basics", expectedQuestions: 20 },
    { id: 7, name: "Ethernet Switching Basics", expectedQuestions: 5 },
    { id: 8, name: "VLAN Principles and Configuration", expectedQuestions: 12 },
    { id: 9, name: "STP Principles and Configuration", expectedQuestions: 10 },
    { id: 10, name: "Inter-VLAN Communication", expectedQuestions: 2 },
    { id: 11, name: "Eth-Trunk iStack and CSS", expectedQuestions: 5 },
    { id: 12, name: "ACL Principles and Configuration", expectedQuestions: 6 },
    { id: 13, name: "AAA Principles and Configuration", expectedQuestions: 5 },
    { id: 14, name: "Network Address Translation", expectedQuestions: 7 },
    { id: 15, name: "Network Services and Applications", expectedQuestions: 9 },
    { id: 16, name: "WLAN Overview", expectedQuestions: 16 },
    { id: 17, name: "WAN Technologies", expectedQuestions: 4 },
    { id: 18, name: "Network Management and OM", expectedQuestions: 4 },
    { id: 19, name: "IPv6 Basics", expectedQuestions: 10 },
    { id: 20, name: "Introduction to SDN and NFV", expectedQuestions: 2 },
    { id: 21, name: "Network Programmability and Automation", expectedQuestions: 2 },
    { id: 22, name: "Typical Campus Network Architectures and Practices", expectedQuestions: 9 }
];

// Initialize the application
async function initApp() {
    console.log("üîß Initializing HCIA Quiz App...");
    await loadQuestions();
    setupEventListeners();
    renderChapters();
    updateProgress();
    updateQuickStats();
    showScreen('mainMenu');
    console.log("‚úÖ HCIA Quiz App Ready!");
}

// Setup event listeners
function setupEventListeners() {
    console.log("üîß Setting up event listeners...");
    
    // Fix back button navigation
    const backBtn = document.getElementById('settingsBackBtn');
    if (backBtn) {
        backBtn.addEventListener('click', function() {
            console.log("üîô Back button clicked, quizType:", quizState.quizType);
            if (quizState.quizType === 'chapter') {
                showChapterSelection();
            } else {
                showMainMenu();
            }
        });
    }
    
    // Enter key support for chapter search
    const searchInput = document.getElementById('chapterSearch');
    if (searchInput) {
        searchInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                filterChapters();
            }
        });
    }
    
    console.log("‚úÖ Event listeners setup complete");
}

// Load questions from JSON file with fallback
async function loadQuestions() {
    console.log("üì• Loading questions...");
    try {
        const response = await fetch('data.json');
        if (!response.ok) throw new Error('data.json not found');
        const data = await response.json();
        quizState.questions = data.questions;
        console.log(`‚úÖ Loaded ${quizState.questions.length} questions from data.json`);
    } catch (error) {
        console.warn('‚ùå Could not load data.json, using fallback questions:', error.message);
        quizState.questions = getFallbackQuestions();
        console.log(`‚úÖ Loaded ${quizState.questions.length} fallback questions`);
    }
    updateQuickStats();
}

// Update quick stats in main menu
function updateQuickStats() {
    const totalQuestions = quizState.questions.length;
    const chaptersCompleted = Object.keys(quizState.progress).length;
    const avgScore = calculateAverageScore();
    
    const totalEl = document.getElementById('totalQuestions');
    const completedEl = document.getElementById('chaptersCompleted');
    const avgEl = document.getElementById('avgScore');
    
    if (totalEl) totalEl.textContent = totalQuestions;
    if (completedEl) completedEl.textContent = chaptersCompleted;
    if (avgEl) avgEl.textContent = avgScore + '%';
    
    console.log(`üìä Stats updated: ${totalQuestions} questions, ${chaptersCompleted} chapters completed, ${avgScore}% avg`);
}

function calculateAverageScore() {
    let totalScore = 0;
    let totalAttempts = 0;
    
    Object.values(quizState.progress).forEach(attempts => {
        attempts.forEach(attempt => {
            totalScore += attempt.percentage;
            totalAttempts++;
        });
    });
    
    return totalAttempts > 0 ? Math.round(totalScore / totalAttempts) : 0;
}

// Screen navigation
function showScreen(screenId) {
    console.log(`üîÑ Switching to screen: ${screenId}`);
    document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('active');
    });
    
    const targetScreen = document.getElementById(screenId);
    if (targetScreen) {
        targetScreen.classList.add('active');
        quizState.currentScreen = screenId;
    } else {
        console.error(`‚ùå Screen not found: ${screenId}`);
    }
    
    if (screenId === 'mainMenu') {
        updateQuickStats();
    }
}

function showMainMenu() {
    showScreen('mainMenu');
}

function showChapterSelection() {
    showScreen('chapterSelection');
}

// Filter chapters based on search
function filterChapters() {
    const searchTerm = document.getElementById('chapterSearch').value.toLowerCase();
    const chapterCards = document.querySelectorAll('.chapter-card');
    
    let visibleCount = 0;
    chapterCards.forEach(card => {
        const chapterName = card.querySelector('.chapter-name').textContent.toLowerCase();
        const chapterNumber = card.querySelector('.chapter-number').textContent;
        
        if (chapterName.includes(searchTerm) || chapterNumber.includes(searchTerm)) {
            card.style.display = 'block';
            visibleCount++;
        } else {
            card.style.display = 'none';
        }
    });
    
    console.log(`üîç Filtered chapters: ${visibleCount} visible`);
}

// Render chapters grid with progress
function renderChapters() {
    const chaptersGrid = document.getElementById('chaptersGrid');
    if (!chaptersGrid) {
        console.error('‚ùå chaptersGrid element not found');
        return;
    }
    
    const chapterHTML = chapters.map(chapter => {
        const chapterQuestions = quizState.questions.filter(q => q.chapter === chapter.id).length;
        const chapterProgress = quizState.progress[chapter.id] || [];
        const bestScore = chapterProgress.length > 0 ? 
            Math.max(...chapterProgress.map(attempt => attempt.percentage)) : 0;
        
        const progressClass = getProgressClass(bestScore);
        const progressBadge = bestScore > 0 ? 
            `<div class="chapter-progress ${progressClass}">Best: ${bestScore}%</div>` : '';
        
        return `
            <div class="chapter-card" onclick="selectChapter(${chapter.id})" data-chapter-id="${chapter.id}">
                <div class="chapter-number">${chapter.id}</div>
                <div class="chapter-name">${chapter.name}</div>
                <div class="question-count">${chapterQuestions} questions</div>
                ${progressBadge}
            </div>
        `;
    }).join('');
    
    chaptersGrid.innerHTML = chapterHTML;
    console.log(`‚úÖ Rendered ${chapters.length} chapters`);
}

function getProgressClass(percentage) {
    if (percentage >= 90) return 'excellent';
    if (percentage >= 80) return 'good';
    if (percentage >= 70) return 'average';
    return 'poor';
}

// Chapter selection
function selectChapter(chapterId) {
    console.log(`üìö Chapter selected: ${chapterId}`);
    quizState.selectedChapter = chapterId;
    const chapter = chapters.find(c => c.id === chapterId);
    const chapterQuestions = quizState.questions.filter(q => q.chapter === chapterId).length;
    
    document.getElementById('settingsTitle').textContent = 
        `Chapter ${chapterId}: ${chapter.name}`;
    
    updateQuestionOptions(chapterQuestions);
    showScreen('quizSettings');
}

// Update question options based on available questions
function updateQuestionOptions(maxQuestions) {
    const questionCountSelect = document.getElementById('questionCount');
    if (!questionCountSelect) {
        console.error('‚ùå questionCount select element not found');
        return;
    }
    
    let options = [];
    
    if (quizState.quizType === 'exam') {
        // Exam sessions: 50, 50, 38
        const examSessions = [
            { value: 50, label: "Session 1: 50 Questions" },
            { value: 50, label: "Session 2: 50 Questions" },
            { value: 38, label: "Session 3: 38 Questions" }
        ];
        
        examSessions.forEach(session => {
            if (session.value <= maxQuestions) {
                options.push(`<option value="${session.value}">${session.label}</option>`);
            }
        });
        
        // If no session fits, add max available
        if (options.length === 0 && maxQuestions > 0) {
            options.push(`<option value="${maxQuestions}">All ${maxQuestions} Questions</option>`);
        }
    } else {
        // Chapter and Random quiz options
        const standardOptions = [5, 10, 15, 20, 25, 30];
        standardOptions.forEach(opt => {
            if (opt <= maxQuestions) {
                const selected = opt === 10 ? 'selected' : '';
                options.push(`<option value="${opt}" ${selected}>${opt} Questions</option>`);
            }
        });
        
        // Always add the maximum available if not already included
        if (maxQuestions > 0 && !options.some(opt => opt.includes(`value="${maxQuestions}"`))) {
            options.push(`<option value="${maxQuestions}">All ${maxQuestions} Questions</option>`);
        }
    }
    
    questionCountSelect.innerHTML = options.join('');
    console.log(`‚úÖ Updated question options: ${options.length} options for max ${maxQuestions} questions`);
}

// Quiz initialization
function startChapterQuiz() {
    console.log("üéØ Starting Chapter Quiz");
    quizState.quizType = 'chapter';
    showChapterSelection();
}

function startRandomQuiz() {
    console.log("üé≤ Starting Random Quiz");
    quizState.quizType = 'random';
    document.getElementById('settingsTitle').textContent = 'Random Quiz Settings';
    updateQuestionOptions(Math.min(50, quizState.questions.length));
    showScreen('quizSettings');
}

function startExam() {
    console.log("üìù Starting Final Exam");
    quizState.quizType = 'exam';
    document.getElementById('settingsTitle').textContent = 'Final Exam Settings';
    updateQuestionOptions(quizState.questions.length);
    showScreen('quizSettings');
}

function startQuiz() {
    const questionCount = parseInt(document.getElementById('questionCount').value);
    const difficultyFilter = document.getElementById('difficultyFilter').value;
    
    console.log(`üöÄ Starting quiz: ${questionCount} questions, difficulty: ${difficultyFilter}, type: ${quizState.quizType}`);
    
    let availableQuestions = [];
    
    // Filter questions based on quiz type
    if (quizState.quizType === 'chapter') {
        availableQuestions = quizState.questions.filter(q => q.chapter === quizState.selectedChapter);
        console.log(`üìö Chapter ${quizState.selectedChapter} questions: ${availableQuestions.length}`);
    } else {
        availableQuestions = [...quizState.questions];
    }
    
    // Apply difficulty filter
    if (difficultyFilter !== 'all') {
        availableQuestions = availableQuestions.filter(q => q.difficulty === difficultyFilter);
        console.log(`üéØ Difficulty filtered: ${availableQuestions.length} questions`);
    }
    
    // Shuffle and select questions
    quizState.currentQuestions = shuffleArray(availableQuestions).slice(0, questionCount);
    quizState.currentQuestionIndex = 0;
    quizState.userAnswers = new Array(quizState.currentQuestions.length).fill(null);
    quizState.quizStartTime = Date.now();
    
    if (quizState.currentQuestions.length === 0) {
        alert('‚ùå No questions available with the selected criteria. Please try different settings.');
        console.error('No questions available after filtering');
        return;
    }
    
    console.log(`‚úÖ Quiz ready: ${quizState.currentQuestions.length} questions loaded`);
    showQuizScreen();
}

function shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
}

function showQuizScreen() {
    showScreen('quizScreen');
    displayCurrentQuestion();
}

function displayCurrentQuestion() {
    const question = quizState.currentQuestions[quizState.currentQuestionIndex];
    const totalQuestions = quizState.currentQuestions.length;
    
    if (!question) {
        console.error('‚ùå No question found at index:', quizState.currentQuestionIndex);
        return;
    }
    
    // Update progress
    document.getElementById('questionCounter').textContent = 
        `${quizState.currentQuestionIndex + 1}/${totalQuestions}`;
    
    const progressPercent = ((quizState.currentQuestionIndex + 1) / totalQuestions) * 100;
    document.getElementById('quizProgress').style.width = `${progressPercent}%`;
    
    // Update quiz type display
    let quizTypeText = 'Chapter Quiz';
    if (quizState.quizType === 'random') quizTypeText = 'Random Quiz';
    if (quizState.quizType === 'exam') quizTypeText = 'Final Exam';
    document.getElementById('quizType').textContent = quizTypeText;
    
    // Update question content
    document.getElementById('questionChapter').textContent = `Chapter ${question.chapter}`;
    document.getElementById('questionTopic').textContent = question.topic || chapters.find(c => c.id === question.chapter)?.name || 'General';
    document.getElementById('questionText').textContent = question.text;
    
    const difficultyText = question.difficulty.charAt(0).toUpperCase() + question.difficulty.slice(1);
    document.getElementById('currentDifficulty').textContent = difficultyText;
    
    // Update options
    const optionsContainer = document.getElementById('optionsContainer');
    optionsContainer.innerHTML = '';
    
    question.options.forEach((option, index) => {
        const optionElement = document.createElement('div');
        optionElement.className = 'option';
        if (quizState.userAnswers[quizState.currentQuestionIndex] === index) {
            optionElement.classList.add('selected');
        }
        optionElement.textContent = option;
        optionElement.onclick = () => selectOption(index);
        optionsContainer.appendChild(optionElement);
    });
    
    // Update navigation buttons
    document.getElementById('prevBtn').disabled = quizState.currentQuestionIndex === 0;
    document.getElementById('nextBtn').classList.toggle('hidden', 
        quizState.currentQuestionIndex === totalQuestions - 1);
    document.getElementById('finishBtn').classList.toggle('hidden', 
        quizState.currentQuestionIndex !== totalQuestions - 1);
    
    console.log(`üìù Displaying question ${quizState.currentQuestionIndex + 1}/${totalQuestions}`);
}

function selectOption(optionIndex) {
    quizState.userAnswers[quizState.currentQuestionIndex] = optionIndex;
    displayCurrentQuestion();
}

function previousQuestion() {
    if (quizState.currentQuestionIndex > 0) {
        quizState.currentQuestionIndex--;
        displayCurrentQuestion();
    }
}

function nextQuestion() {
    if (quizState.currentQuestionIndex < quizState.currentQuestions.length - 1) {
        quizState.currentQuestionIndex++;
        displayCurrentQuestion();
    }
}

function showResults() {
    const totalQuestions = quizState.currentQuestions.length;
    const correctAnswers = quizState.userAnswers.reduce((count, answer, index) => {
        return count + (answer === quizState.currentQuestions[index].correctAnswer ? 1 : 0);
    }, 0);
    
    const percentage = Math.round((correctAnswers / totalQuestions) * 100);
    const timeSpent = Math.round((Date.now() - quizState.quizStartTime) / 1000);
    
    console.log(`üìä Quiz completed: ${correctAnswers}/${totalQuestions} (${percentage}%) in ${timeSpent}s`);
    
    // Update results display
    document.getElementById('finalScore').textContent = `${correctAnswers}/${totalQuestions}`;
    document.getElementById('scorePercentage').textContent = `${percentage}%`;
    document.getElementById('correctAnswers').textContent = correctAnswers;
    document.getElementById('incorrectAnswers').textContent = totalQuestions - correctAnswers;
    document.getElementById('timeSpent').textContent = `${timeSpent}s`;
    
    // Update results message
    let message = '';
    let messageClass = '';
    if (percentage >= 90) {
        message = 'üéâ Excellent! You have mastered this content.';
        messageClass = 'excellent';
    } else if (percentage >= 80) {
        message = 'üëç Great job! You have a good understanding.';
        messageClass = 'good';
    } else if (percentage >= 70) {
        message = 'üí™ Good effort! Review the incorrect answers.';
        messageClass = 'average';
    } else {
        message = 'üìö Keep practicing! Focus on the weak areas.';
        messageClass = 'poor';
    }
    document.getElementById('resultsMessage').textContent = message;
    
    // Update progress tracking
    updateProgressTracking(correctAnswers, totalQuestions, percentage);
    
    // Show results details
    showResultsDetails();
    
    showScreen('resultsScreen');
}

function updateProgressTracking(correct, total, percentage) {
    if (quizState.quizType === 'chapter' && quizState.selectedChapter) {
        const chapterId = quizState.selectedChapter;
        if (!quizState.progress[chapterId]) {
            quizState.progress[chapterId] = [];
        }
        
        quizState.progress[chapterId].push({
            date: new Date().toISOString(),
            score: correct,
            total: total,
            percentage: percentage
        });
        
        // Keep only last 5 attempts
        if (quizState.progress[chapterId].length > 5) {
            quizState.progress[chapterId] = quizState.progress[chapterId].slice(-5);
        }
        
        localStorage.setItem('hciaQuizProgress', JSON.stringify(quizState.progress));
        updateProgress();
        
        console.log(`üíæ Progress saved for chapter ${chapterId}: ${percentage}%`);
    }
}

function updateProgress() {
    const totalChapters = chapters.length;
    const completedChapters = Object.keys(quizState.progress).length;
    const progressPercentage = Math.round((completedChapters / totalChapters) * 100);
    
    document.getElementById('progressText').textContent = `${progressPercentage}% Complete`;
    
    const progressFill = document.getElementById('progressFill');
    progressFill.style.width = `${progressPercentage}%`;
    progressFill.className = 'progress-fill ' + getProgressClass(progressPercentage);
    
    console.log(`üìà Progress updated: ${completedChapters}/${totalChapters} chapters (${progressPercentage}%)`);
}

function showResultsDetails() {
    const resultsList = document.getElementById('resultsList');
    resultsList.innerHTML = '';
    
    quizState.currentQuestions.forEach((question, index) => {
        const userAnswer = quizState.userAnswers[index];
        const isCorrect = userAnswer === question.correctAnswer;
        
        const resultItem = document.createElement('div');
        resultItem.className = `result-item ${isCorrect ? 'correct' : 'incorrect'}`;
        
        let userAnswerText = 'Not answered';
        if (userAnswer !== null && userAnswer !== undefined) {
            userAnswerText = question.options[userAnswer];
        }
        
        resultItem.innerHTML = `
            <strong>Question ${index + 1}: ${isCorrect ? '‚úì Correct' : '‚úó Incorrect'}</strong>
            <div>${question.text}</div>
            <div><strong>Your answer:</strong> ${userAnswerText}</div>
            ${!isCorrect ? `<div><strong>Correct answer:</strong> ${question.options[question.correctAnswer]}</div>` : ''}
            ${question.explanation ? `<div class="explanation"><strong>Explanation:</strong> ${question.explanation}</div>` : ''}
        `;
        
        resultsList.appendChild(resultItem);
    });
    
    console.log(`üìã Results details: ${quizState.currentQuestions.length} questions displayed`);
}

function retryQuiz() {
    console.log("üîÑ Retrying quiz...");
    startQuiz();
}

function showWeakAreas() {
    console.log("üîç Analyzing weak areas...");
    
    // Calculate weak areas based on incorrect answers
    quizState.weakAreas = [];
    const chapterErrors = {};
    
    quizState.currentQuestions.forEach((question, index) => {
        if (quizState.userAnswers[index] !== question.correctAnswer) {
            const chapterId = question.chapter;
            if (!chapterErrors[chapterId]) {
                chapterErrors[chapterId] = 0;
            }
            chapterErrors[chapterId]++;
        }
    });
    
    // Convert to weak areas array
    Object.keys(chapterErrors).forEach(chapterId => {
        const chapter = chapters.find(c => c.id === parseInt(chapterId));
        if (chapter) {
            quizState.weakAreas.push({
                chapterId: parseInt(chapterId),
                chapterName: chapter.name,
                errorCount: chapterErrors[chapterId]
            });
        }
    });
    
    // Sort by error count (descending)
    quizState.weakAreas.sort((a, b) => b.errorCount - a.errorCount);
    
    // Display weak areas
    const weakAreasList = document.getElementById('weakAreasList');
    weakAreasList.innerHTML = '';
    
    if (quizState.weakAreas.length === 0) {
        weakAreasList.innerHTML = '<div class="weak-area-item"><h4>üéâ No Weak Areas Found!</h4><p>Great job! You answered all questions correctly.</p></div>';
    } else {
        quizState.weakAreas.forEach(area => {
            const areaItem = document.createElement('div');
            areaItem.className = 'weak-area-item';
            areaItem.innerHTML = `
                <h4>Chapter ${area.chapterId}: ${area.chapterName}</h4>
                <p><strong>Incorrect answers:</strong> ${area.errorCount}</p>
                <button class="btn-secondary" onclick="practiceChapter(${area.chapterId})">Practice This Chapter</button>
            `;
            weakAreasList.appendChild(areaItem);
        });
    }
    
    console.log(`üìâ Weak areas identified: ${quizState.weakAreas.length} chapters need improvement`);
    showScreen('weakAreas');
}

function practiceChapter(chapterId) {
    console.log(`üìö Practicing chapter: ${chapterId}`);
    quizState.quizType = 'chapter';
    selectChapter(chapterId);
}

// Comprehensive fallback questions
function getFallbackQuestions() {
    console.log("üîÑ Loading fallback questions...");
    return [
        {
            id: 1,
            chapter: 1,
            topic: "Network Communication",
            text: "Making a call on a landline telephone is a type of network communication.",
            options: ["True", "False"],
            correctAnswer: 0,
            difficulty: "easy",
            explanation: "Landline telephone communication uses circuit-switched networks, which is a form of network communication."
        },
        {
            id: 2,
            chapter: 1,
            topic: "OSI Model",
            text: "What are the components of the OSI reference model from top to bottom?",
            options: [
                "Application, Presentation, Session, Transport, Network, Data Link, Physical",
                "Physical, Data Link, Network, Transport, Session, Presentation, Application",
                "Application, Session, Presentation, Transport, Network, Data Link, Physical",
                "Physical, Network, Data Link, Transport, Session, Presentation, Application"
            ],
            correctAnswer: 0,
            difficulty: "medium",
            explanation: "The OSI model layers from top to bottom are: Application, Presentation, Session, Transport, Network, Data Link, Physical."
        },
        {
            id: 3,
            chapter: 1,
            topic: "Gateway Configuration",
            text: "A gateway must be configured for communication between a host and other hosts.",
            options: ["True", "False"],
            correctAnswer: 1,
            difficulty: "easy",
            explanation: "A gateway is only needed when communicating with hosts on different networks. Hosts on the same network can communicate directly without a gateway."
        },
        {
            id: 4,
            chapter: 1,
            topic: "Router Functions",
            text: "Which statement about routers is false?",
            options: [
                "Routers operate at the network layer",
                "Routers can connect different network types",
                "A router cannot isolate broadcast domains",
                "Routers use IP addresses for forwarding decisions"
            ],
            correctAnswer: 2,
            difficulty: "medium",
            explanation: "Routers DO isolate broadcast domains - each router interface creates a separate broadcast domain, which is one of their key functions."
        },
        {
            id: 5,
            chapter: 2,
            topic: "Network Layer Protocols",
            text: "When the host accesses web service, the value of the 'Protocol' field at the network layer is 6.",
            options: ["True", "False"],
            correctAnswer: 0,
            difficulty: "medium",
            explanation: "The protocol field value 6 indicates TCP, which is used for web services (HTTP/HTTPS)."
        },
        {
            id: 6,
            chapter: 2,
            topic: "Ethernet Frames",
            text: "If 'Type/Length' field is 0x0800, the upper-layer packet header length is 20B to 60B.",
            options: ["True", "False"],
            correctAnswer: 0,
            difficulty: "hard",
            explanation: "0x0800 indicates IPv4, whose header length is 20-60 bytes depending on options field."
        },
        {
            id: 7,
            chapter: 2,
            topic: "FTP Protocol",
            text: "How many TCP connections are used in FTP?",
            options: ["1", "2", "3", "4"],
            correctAnswer: 1,
            difficulty: "medium",
            explanation: "FTP uses two TCP connections: control connection (port 21) for commands and data connection (port 20) for data transfer."
        },
        {
            id: 8,
            chapter: 2,
            topic: "VLAN Tagging",
            text: "'Length/Type' 0x8100 indicates VLAN tag.",
            options: ["True", "False"],
            correctAnswer: 0,
            difficulty: "medium",
            explanation: "Ethernet type 0x8100 indicates an IEEE 802.1Q VLAN tagged frame used for VLAN identification."
        },
        {
            id: 9,
            chapter: 3,
            topic: "VRP File Management",
            text: "Files cannot be permanently deleted using delete /unreserved.",
            options: ["True", "False"],
            correctAnswer: 1,
            difficulty: "easy",
            explanation: "delete /unreserved DOES permanently delete files from the storage device without moving to recycle bin."
        },
        {
            id: 10,
            chapter: 3,
            topic: "VRP Configuration",
            text: "Changing router name requires System-view.",
            options: ["True", "False"],
            correctAnswer: 0,
            difficulty: "easy",
            explanation: "System view is required to change the device name using the sysname command in Huawei VRP."
        },
        {
            id: 11,
            chapter: 4,
            topic: "IP Addressing",
            text: "Which of the following is a private IP address?",
            options: [
                "192.168.1.1",
                "8.8.8.8",
                "203.0.113.1",
                "198.51.100.1"
            ],
            correctAnswer: 0,
            difficulty: "easy",
            explanation: "192.168.1.1 is in the private IP range 192.168.0.0/16. Others are public IP addresses."
        },
        {
            id: 12,
            chapter: 6,
            topic: "OSPF Basics",
            text: "OSPF Router ID takes effect immediately after configuration.",
            options: ["True", "False"],
            correctAnswer: 1,
            difficulty: "medium",
            explanation: "OSPF Router ID changes require OSPF process reset or router reboot to take effect."
        }
        // Add more questions here to reach 138+ total
    ];
}

// Initialize the app when the page loads
document.addEventListener('DOMContentLoaded', function() {
    console.log("üìÑ DOM Content Loaded - Starting HCIA Quiz App");
    initApp().catch(error => {
        console.error('‚ùå Failed to initialize app:', error);
    });
});

// Global error handler
window.addEventListener('error', function(e) {
    console.error('üö® Global error:', e.error);
});

console.log("‚úÖ HCIA Quiz Application Script Loaded");
